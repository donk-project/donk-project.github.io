<!doctype html><html lang=en><title>Donk Project</title><meta charset=utf8><meta content=summary name=twitter:card><meta content=https://donk-project.github.io/header.png name=twitter:image><meta content="Donk Project: A C++ Transpiler for BYOND"name=twitter:title><meta content=https://donk-project.github.io/header.png property=og:image><meta content="Donk Project: A C++ Transpiler for BYOND"property=og:title><meta content=website property=og:type><meta content=https://donk-project.github.io/ property=og:url><style>/*! Typebase.less v0.1.0 | MIT License */html{font-family:-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Ubuntu,roboto,noto,segoe ui,arial,sans-serif;font-size:120%;-webkit-font-smoothing:antialiased}p{line-height:1.7rem;margin-top:1.5rem;margin-bottom:1.5rem}ol,ul{margin-top:1.5rem;margin-bottom:1.5rem}ol li,ul li{line-height:1.5rem;margin-top:.5rem;margin-bottom:.2rem}ol li p,ul li p{line-height:1.5rem;margin-top:.2rem;margin-bottom:.2rem}ol ol,ol ul,ul ol,ul ul{margin-top:.5rem;margin-bottom:0}blockquote{line-height:1.5rem;margin-top:1.5rem;margin-bottom:1.5rem}h1,h2,h3,h4,h5,h6{font-family:sans-serif;margin-top:1.5rem;margin-bottom:1.5rem;line-height:1.5rem}h1{font-size:4.242rem;line-height:4.5rem;margin-top:3rem}h2{font-size:2.828rem;line-height:3rem;margin-top:3rem}h3{font-size:1.714rem}h4{font-size:1.414rem}h5{font-size:.4713333333333333rem}h6{font-size:.3535rem}table{margin-top:1.5rem;border-spacing:0;border-collapse:collapse}table td,table th{padding:4px;line-height:33px}code{vertical-align:bottom}.lead{font-size:1.414rem}.hug{margin-top:0}footer{font-size:50%;color:#666}body{margin:2em auto;background-color:#222;color:#eee;width:700px}article{font-size:120%}img{margin:1em 0}a{background-color:#222;color:#ddd}a:hover{background-color:#ddd;color:#222}a code:hover{background-color:#ddd;color:#222}code{font-size:90%;font-family:Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace;color:#fd0088}#logo img{width:100px;margin:0 auto;border-radius:50px;border:2px solid #999}a#logo{background-color:#000;color:#000}a#logo img:hover{border-color:#fd0088}span.author{font-size:80%;color:#999}span.author code{color:#999}#table-of-contents a{display:none}h1 a{display:none}h2 a,h3 a,h4 a,h5 a,h6 a{vertical-align:super;font-size:50%;background-color:#000;color:#555;text-decoration:none}article img{width:100%}footer{margin-top:4em}blockquote{border-left:4px solid #333;padding-left:.5em}code{font-size:90%;color:#bfbfbf;background-color:#111}</style></head><body><article><h1 id=donk-project>Donk Project<a href=#donk-project aria-hidden=true tabindex=-1>#</a></h1><p>Donk Project is an attempt to create a <em>clean-room</em> implementation of BYOND that supports existing Dreammaker codebases via transpilation to C++.<h2 id=table-of-contents>Table of Contents<a href=#table-of-contents aria-hidden=true tabindex=-1>#</a></h2><ul><li><p><a href=#overview>Overview</a><li><p><a href=#technical-details>Technical Details</a><ul><li><a href=#donkcore><code>donk/core</code></a><li><a href=#donkapi><code>donk/api</code></a><li><a href=#donkinterpreter><code>donk/interpreter</code></a><li><a href=#donktranspiler><code>donk/transpiler</code></a><li><a href=#pollux>Pollux</a></ul><li><p><a href=#building-donk>Building Donk</a><ul><li><a href=#bazel>Bazel</a><li><a href=#the-buildbase>The Buildbase</a><li><a href=#generating-an-ast>Generating an AST</a><li><a href=#building-the-transpiler-output>Building the Transpiler Output</a></ul></ul><h2 id=overview>Overview<a href=#overview aria-hidden=true tabindex=-1>#</a></h2><p>There are several components either in development or planned:<table><thead><tr><th>Project<th>Description<tbody><tr><td>Pollux<td>Dreamseeker client/server implementation<tr><td><a href=https://github.com/donk-project/api><code>donk/api</code></a><td>An implementation of the Dreammaker API<tr><td><a href=https://github.com/donk-project/core><code>donk/core</code></a><td>The core library and description of DM types<tr><td><a href=https://github.com/donk-project/interpreter><code>donk/interpreter</code></a><td>The real-time interpreter for Donk programs<tr><td><a href=https://github.com/donk-project/transpiler><code>donk/transpiler</code></a><td>A transpiler from Dreammaker to C++</table><h2 id=technical-details>Technical Details<a href=#technical-details aria-hidden=true tabindex=-1>#</a></h2><p>The tools dealing with C++ target C++17. This enables us to make use of standard library features such as <code>std::variant</code>, <code>std::any</code>, <code>std::filesystem</code>, and so on.<p>Currently builds are only being tested on macOS. Testing will expand to other platforms once the build rules used for the currently included libraries is configured properly.<p>The various tooling is written in a variety of languages, usually to use whatever tool was close by and could do the job quickly.<h3 id=donkcore><code>donk/core</code><a href=#donkcore aria-hidden=true tabindex=-1>#</a></h3><p><code>donk/core</code> is our lightweight representation of the DM object tree. It is broken up into the following pieces:<ul><li><p><code>donk::path_t</code> is the path representation. All type paths are normalized when ingested. For example, <code>/mob</code> always becomes <code>/datum/atom/movable/mob</code>.<li><p><code>donk::var_t</code> is the variable type representation. At its core, it is a <code>std::variant</code> closed over the possible field types, including primitives, paths, and objects. Vars are stored in a <code>donk::var_table_t</code>.<li><p><code>donk::proc_table_t</code> is how proc references are assigned to objects. BYOND allows procs to be added or removed to objects during runtime, so we store refernces to free functions by name, rather than using member functions.<li><p><code>donk::iota_t</code> is the object type representation in Donk. It has one of each of the <code>var_table_t</code> and <code>proc_table_t</code> described above, as well as a reference to the interpreter that spawned them.</ul><h3 id=donkapi><code>donk/api</code><a href=#donkapi aria-hidden=true tabindex=-1>#</a></h3><p><code>donk/api</code> is an implementation of the BYOND API in a format copasetic with the above tooling. The implementation is informed by the <em><a href=http://www.byond.com/docs/guide/guide.pdf>Designerâ€™s Guide</a></em>, the <a href=https://secure.byond.com/docs/ref/>Dreammaker Reference</a>, and various SS13 codebases. At the moment the design of this implementation is up in the air, so it is unclear how much behavior will end up in here versus <code>donk/core</code>.<h3 id=donkinterpreter><code>donk/interpreter</code><a href=#donkinterpreter aria-hidden=true tabindex=-1>#</a></h3><p>The interpreter registers all the types, procs, and vars defined in the transpiled source code, and provides a command interface in order to receive tasks. It is currently only capable of incredibly simple statement parsing, but will soon include an appropriate task scheduler and command parser.<h3 id=donktranspiler><code>donk/transpiler</code><a href=#donktranspiler aria-hidden=true tabindex=-1>#</a></h3><p><code>donk/transpiler</code> is a transpiler from Dreammaker source to C++17, written in Go. It works by ingesting a representation of a Dreammaker codebase, and then emitting the output into a specified directory. The codebase may then be included in client and server targets.<h3 id=pollux>Pollux<a href=#pollux aria-hidden=true tabindex=-1>#</a></h3><p>Pollux is the server and GUI client for built Donk libraries. It is currently in its very early stages, but is backed by <a href=https://sfml-dev.org>SFML</a>, <a href=http://enet.bespin.org>enet</a>, and <a href=https://developers.google.com/protocol-buffers>Protobuf</a>. The networking aspect of Pollux may be pulled out into a separate component, as well.<p>Here is an in-progress screenshot of Pollux. So far, the client is connected to the headless Pollux server, and has the ability to receive map data and entity updates from the server.<p><img alt="In-progress Pollux screenshot"src=pollux_progress.png><h2 id=building-donk>Building Donk<a href=#building-donk aria-hidden=true tabindex=-1>#</a></h2><h3 id=bazel>Bazel<a href=#bazel aria-hidden=true tabindex=-1>#</a></h3><p>With the exception of Cargo in the SpacemanDMM repository, <a href=https://bazel.build>Bazel</a> is the sole build tool used across the project, regardless of language or tooling. While it is is still evolving as a public offering, Bazel makes a lot of things incredibly easy, including chaining together disparate build processes into a coherent dependency graph that can be queried and reasoned about simply. In our case, we can modify the Dreammaker AST proto, the transpiler in Golang, or the C++ source code of the API, and be confident that the correct artifacts are rebuilt every step of the way.<p>In Bazel, individual projects or components are delineated with a <code>WORKSPACE.bazel</code> file in the project root. Projects are broken up into packages, one package per <code>BUILD.bazel</code> file in the workspace.<p>Each separate component of Donk has its own <code>WORKSPACE.bazel</code> that informs it of needed dependencies. The dependencies between projects are represented by packages, whose names can be linked to either the published repositories or local copies.<h3 id=the-buildbase>The Buildbase<a href=#the-buildbase aria-hidden=true tabindex=-1>#</a></h3><p>All one needs to start building Donk Project is the sole <code>WORKSPACE.bazel</code> provided in <a href=https://github.com/donk-project/buildbase>donk-project/buildbase</a>. Building or running any of the targets will automatically integrate HEAD versions of all the relevant repos.<h3 id=generating-an-ast>Generating an AST<a href=#generating-an-ast aria-hidden=true tabindex=-1>#</a></h3><p>In order to provide a BYOND environment in the proper format, clone the <code>pb2</code> branch of this SpacemanDMM repository fork: <a href=https://github.com/warriorstar-orion/SpacemanDMM/tree/pb2>warriorstar-orion/SpacemanDMM</a>. Then, from within the working directory of a BYOND environment that compiles cleanly, use the dm2pb script to generate the binary proto, as in this example:<pre><code>$ cargo run --manifest-path=path/to/SpacemanDMM/src/dm2pb/Cargo.toml \
    --bin=dreammaker2pb
</code></pre><p>The resultant <code>output.binarypb</code> file can be fed to the Donk Transpiler. In the future, hopefully this step can be reduced to another Bazel command.<h3 id=building-the-transpiler-output>Building the Transpiler Output<a href=#building-the-transpiler-output aria-hidden=true tabindex=-1>#</a></h3><p>We assign an arbitrary library name to the output of the transpiler; the default is <code>tgcc</code>. Run the transpiler with Bazel:<pre><code>$ bazel run @donk_transpiler//:main -- \
    --input_proto /path/to/dme/output.binarypb \
    --output_path /path/to/tgcc
</code></pre><p>This will create the directory provided in <code>--output_path</code> and emit C++ source files into it.<p>The Buildbase <code>WORKSPACE.bazel</code> provides the build target as long as one provides the output path of the transpiler. This allows one to immediately run <code>bazel build @tgcc</code> and verify that the generated C++ library builds correctly.<p>Finally, use Bazel to run the Runner, which will automatically link in the tgcc library and execute <code>/proc/main()</code> if it can find it.<p>Here is an example of a very simple DM program being executed in the interpreter and returning the output which was redirected to <code>world</code>. Other supported constructs are <code>new/obj</code> and var declaration.<p><img alt src=transpiler_input.png><p><img alt src=runner_output.png></article><footer>Copyright (c) 2021 Warriorstar Orion. You wanna put a bangin' donk on it.</footer></body></html>